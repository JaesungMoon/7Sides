HEAP はプログラムの中で、「必要に応じてシステムから取り」、「使用後にシステムに戻す」という使い方をするメモリのプール領域です。一時的にこの中をさす DP（データ・ポインタ）が使われることもあります。C++ ではヒープのデータを取るには new 演算子を使用し、開放（システムに戻す）には delete 演算子を使用します

STACK は CPU の SP（スタック・ポインタ）で管理されるローカル記憶などをおく領域です。スタックは、アクセスの方法として、机の上に本を積み上げるときのように、下から積んだデータは、上からしか取り崩さないという方式を使います。スタックの主な使用方法は三つで、
一つ目は、関数呼び出しの戻りアドレスを積んでおいて、関数から戻るときにスタックからアドレスを読んで元のアドレスに戻ることです。
二つ目は、関数呼び出しの引数となる変数を積んでから関数を呼び出すことにより関数に引数を引き渡し、関数から戻るときに戻り値をスタックに積んで結果を返すことです。
三つ目は、関数呼び出し後に、その関数で使用するローカル変数をスタックに積んで使用し、関数から戻るときに取り崩して跡形もなく始末することです。

メモリにはいくつかの種類があります。

Global
プログラムの開始と同時に割り当てられ、プログラムが終了するまで開放されることのないメモリです。
関数はすべてグローバルメモリ上に存在します。
関数の外で定義した変数もすべてグローバルメモリ上に存在します。(グローバル変数)

関数の中で定義した変数はローカル変数と呼ばれ、スッタクメモリというメモリに割り当てられます。 スタックメモリはその関数の実行と同時に割り当てられ、実行が終わると開放されるメモリです。関数に渡される引数もスタックメモリ上に存在します。
また、"abcde"などの " でくくった文字列（リテラル文字列）もグローバルメモリ上に存在します。


#include <cstdio>
using namespace std;

int        iValue1  = 0;        // グローバル領域でメモリを取る。
char       acName[] = "Japan";  // グローバル領域でメモリを取る。
static int iValue2  = 1;        // グローバル領域で static なメモリを取る。

int main() { return 0; }

上記で取った iValue1、acName、iValue2 のメモリは main が実行される前にヒープに取られて居座ります。このメモリは、プログラムが終了するときに開放されてシステムに戻されます。iValue2 には static をつけましたが、グローバル領域での変数はもともと static なので、この場合つけてもつけなくても同じことになります。結論的には、グローバル変数はヒープに取られるということです。

コンピュータの動作中に、使用可能なメモリ容量がだんだん減っていく現象。OSやアプリケーションソフトが処理のために占有したメモリ領域を、なんらかの理由で解放しないまま放置してしまうために起きる。多くの場合、OSのメモリ管理方法に問題があったり、アプリケーションソフトに不具合(バグ)が残っていたりすることが原因である。メモリリークにより利用可能なメモリ領域が減少すると、システムの性能が低下したり、不安定になったりする。これを解消するには、システムを再起動する必要がある。

malloc( )で動的に確保されたメモリ領域は，それに対応するfree( )の呼び出しで適切に解放されなければならない。アプリケーションプログラムが動的に確保したメモリ領域の解放を忘れていると，そのメモリ領域は誰にも使用されることなく，プログラムが終了するまでシステムのメモリ資源を無駄に占有し続けることになる。

このような現象は，「システムのメモリがどこかから漏れて（リーク）足りなくなってゆく」という意味から「メモリリーク」と呼ばれる。メモリリークは，あまり大きな問題ではないように思えるかもしれない。しかし，長時間連続稼動するプログラムでメモリリークが発生している場合，メモリ資源を次々と消費し続けシステムのパフォーマンスを落とすことになる。最悪の場合には，システムが停止する場合もあり得るのである。現実に，メモリリークの欠陥を悪用してプログラムの稼動を妨害するタイプの「サービス不能攻撃」（Denial of Service，DoS）の事例が報告されている。

メモリプラグメンテーション
Don’t using malloc-free a lot.

フラグメンテーション（fragmentation）、断片化（だんぺんか）とは、コンピュータ上のメモリの管理上の一単位が、そのままでは有効利用できない状態になることを言う。
具体的には、使用中のメモリ領域がわずかな大きさの未使用領域を挟んで飛び飛びに配置され、連続した未使用領域が大きく確保できなくなる状態を言う。 このような状態に陥ると、メモリ領域の新たな確保、走査に時間がかかるため、コンピュータのパフォーマンスが低下する傾向にある。

メモリ上での領域確保・解放の操作を長期間繰り返していると、フラグメンテーションは必然的に、主記憶・二次記憶を問わず発生する。これを解消するには、使用中のメモリ領域を移動させ、隣り合わせに配置し直すことで相対的に連続未使用領域を大きくする。この操作をデフラグメンテーション（defragmentation, デフラグ）もしくはメモリ・コンパクション（memory compaction）と呼ぶ。

メモリプール
メモリプールとはあらかじめまとまったメモリ領域を一括で確保した後に確保したメモリ領域を使ってメモリにデータを割り当てる手法、 もしくは確保したメモリ領域をプログラムから効率的に使用/管理できるようなアルゴリズム/データ構造を指す。
メモリプールを使ったプログラミングではプログラム内でメモリの確保と解放を行う箇所をある程度まとめてしまう。 
データを割り当てるためのメモリ領域を一括で確保し、確保したメモリ領域を一括で開放する。

